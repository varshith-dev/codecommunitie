-- ==============================================================================
-- TRUVGO/CODEKRAFTS - FINAL FULL DEPLOYMENT SCRIPT (v1.0)
-- ==============================================================================
-- This script aggregates all schema definitions, modules, functions, and safety fixes
-- into a single executable file. It is idempotent (safe to re-run).

-- ------------------------------------------------------------------------------
-- 1. SETUP & EXTENSIONS
-- ------------------------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ------------------------------------------------------------------------------
-- 2. CORE SCHEMA
-- ------------------------------------------------------------------------------

-- PROFILES
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  username TEXT UNIQUE,
  display_name TEXT,
  bio TEXT,
  website TEXT,
  profile_picture_url TEXT,
  banner_image_url TEXT,
  follower_count INTEGER DEFAULT 0,
  following_count INTEGER DEFAULT 0,
  is_admin BOOLEAN DEFAULT FALSE,
  is_verified BOOLEAN DEFAULT FALSE, -- Added for verification
  role TEXT DEFAULT 'user', -- Added for role management (user, admin, moderator, advertiser)
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- POSTS
CREATE TABLE IF NOT EXISTS public.posts (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('code', 'meme')),
  content_url TEXT,
  code_snippet TEXT,
  code_language TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- LIKES
CREATE TABLE IF NOT EXISTS public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  post_id UUID REFERENCES public.posts ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  UNIQUE(user_id, post_id)
);

-- COMMENTS
CREATE TABLE IF NOT EXISTS public.comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  post_id UUID REFERENCES public.posts ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- FOLLOWS
CREATE TABLE IF NOT EXISTS public.follows (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  following_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  UNIQUE(follower_id, following_id),
  CHECK (follower_id != following_id)
);

-- POST ANALYTICS
CREATE TABLE IF NOT EXISTS public.post_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  post_id UUID REFERENCES public.posts ON DELETE CASCADE NOT NULL,
  view_count INTEGER DEFAULT 0,
  unique_viewers INTEGER DEFAULT 0,
  engagement_rate DECIMAL(5,2) DEFAULT 0.00,
  last_viewed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  UNIQUE(post_id)
);

-- POST VIEWS
CREATE TABLE IF NOT EXISTS public.post_views (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  post_id UUID REFERENCES public.posts ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  viewed_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- ------------------------------------------------------------------------------
-- 3. ADVERTISER MODULE
-- ------------------------------------------------------------------------------

-- AD CAMPAIGNS
CREATE TABLE IF NOT EXISTS public.ad_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    advertiser_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    budget DECIMAL(10,2),
    spent DECIMAL(10,2) DEFAULT 0,
    status TEXT DEFAULT 'draft',
    start_date TIMESTAMPTZ,
    end_date TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ADVERTISEMENTS
CREATE TABLE IF NOT EXISTS public.advertisements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.ad_campaigns(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    image_url TEXT,
    target_url TEXT NOT NULL,
    cta_text TEXT DEFAULT 'Learn More',
    placement TEXT DEFAULT 'feed',
    impressions INT DEFAULT 0,
    clicks INT DEFAULT 0,
    status TEXT DEFAULT 'active',
    approval_status TEXT DEFAULT 'pending', -- pending, approved, rejected
    rejection_reason TEXT,
    approved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- AD METRICS
CREATE TABLE IF NOT EXISTS public.ad_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ad_id UUID REFERENCES public.advertisements(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    action_type TEXT NOT NULL,
    ip_address TEXT,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- AD CREDIT REQUESTS
CREATE TABLE IF NOT EXISTS public.ad_credit_requests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status TEXT DEFAULT 'pending',
    proof_url TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    reviewed_at TIMESTAMPTZ
);

-- AD REPORTS
CREATE TABLE IF NOT EXISTS public.ad_reports (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    ad_id UUID REFERENCES public.advertisements(id) ON DELETE CASCADE NOT NULL,
    reporter_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    reason TEXT NOT NULL,
    details TEXT,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ------------------------------------------------------------------------------
-- 4. VERIFICATION MODULE
-- ------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.verification_requests (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  email TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  full_name TEXT,
  date_of_birth DATE,
  message TEXT,
  admin_notes TEXT,
  requested_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  reviewed_at TIMESTAMP WITH TIME ZONE
);

-- ------------------------------------------------------------------------------
-- 5. PROMPT AUTOMATION MODULE
-- ------------------------------------------------------------------------------

-- AUTOMATION RULES
CREATE TABLE IF NOT EXISTS public.prompt_automations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  trigger_type TEXT NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  icon TEXT DEFAULT 'bell',
  type TEXT DEFAULT 'info',
  action_label TEXT,
  action_url TEXT,
  email_enabled BOOLEAN DEFAULT false,
  email_subject TEXT,
  email_body TEXT,
  duration_seconds INT DEFAULT 0,
  delay_seconds INT DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- USER PROMPTS (The actual notifications shown to users)
CREATE TABLE IF NOT EXISTS public.user_prompts (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  automation_id UUID REFERENCES public.prompt_automations(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  message TEXT,
  action_label TEXT,
  action_url TEXT,
  type TEXT DEFAULT 'info',
  is_dismissed BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- ------------------------------------------------------------------------------
-- 6. INDEXES
-- ------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_posts_user_id ON public.posts(user_id);
CREATE INDEX IF NOT EXISTS idx_likes_post_id ON public.likes(post_id);
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON public.comments(post_id);
CREATE INDEX IF NOT EXISTS idx_campaigns_advertiser ON public.ad_campaigns(advertiser_id);
CREATE INDEX IF NOT EXISTS idx_ads_campaign ON public.advertisements(campaign_id);
CREATE INDEX IF NOT EXISTS idx_user_prompts_user_id ON public.user_prompts(user_id);
CREATE INDEX IF NOT EXISTS idx_verification_requests_user_id ON public.verification_requests(user_id);


-- ------------------------------------------------------------------------------
-- 7. FUNCTIONS & TRIGGERS
-- ------------------------------------------------------------------------------

-- HANDLE NEW USER (Auto Profile)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, display_name, created_at)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    NOW()
  ) ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- HANDLE FOLLOW COUNTS
CREATE OR REPLACE FUNCTION public.handle_follow_count()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.profiles SET follower_count = follower_count + 1 WHERE id = NEW.following_id;
    UPDATE public.profiles SET following_count = following_count + 1 WHERE id = NEW.follower_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.profiles SET follower_count = GREATEST(follower_count - 1, 0) WHERE id = OLD.following_id;
    UPDATE public.profiles SET following_count = GREATEST(following_count - 1, 0) WHERE id = OLD.follower_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_follow_change ON public.follows;
CREATE TRIGGER on_follow_change
  AFTER INSERT OR DELETE ON public.follows
  FOR EACH ROW EXECUTE FUNCTION public.handle_follow_count();


-- HANDLE AD METRICS
CREATE OR REPLACE FUNCTION track_ad_action(
    p_ad_id UUID,
    p_action_type TEXT,
    p_user_id UUID DEFAULT NULL
)
RETURNS void AS $$
BEGIN
    INSERT INTO ad_metrics (ad_id, user_id, action_type) VALUES (p_ad_id, p_user_id, p_action_type);
    IF p_action_type = 'impression' THEN
        UPDATE advertisements SET impressions = impressions + 1 WHERE id = p_ad_id;
    ELSIF p_action_type = 'click' THEN
        UPDATE advertisements SET clicks = clicks + 1 WHERE id = p_ad_id;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- IS EMAIL VERIFIED HELPER
CREATE OR REPLACE FUNCTION public.is_email_verified()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT (email_confirmed_at IS NOT NULL)
    FROM auth.users
    WHERE id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ------------------------------------------------------------------------------
-- 8. FINAL CLEANUP & SAFETY (THE "AUDIT AND FIX" LOGIC)
-- ------------------------------------------------------------------------------
-- This section ensures integrity even if partial schemas existed before.
-- It works DYNAMICALLY to avoid "column does not exist" errors.

DO $$
BEGIN
    -- CLEANUP ORPHANS (Dynamic SQL)
    -- Profiles
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'id') THEN
        EXECUTE 'DELETE FROM public.profiles WHERE id NOT IN (SELECT id FROM auth.users)';
    END IF;
    -- Posts
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'posts' AND column_name = 'user_id') THEN
        EXECUTE 'DELETE FROM public.posts WHERE user_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    -- Comments, Likes, Follows, Verification, Prompts, etc.
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'comments' AND column_name = 'user_id') THEN
        EXECUTE 'DELETE FROM public.comments WHERE user_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'likes' AND column_name = 'user_id') THEN
        EXECUTE 'DELETE FROM public.likes WHERE user_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'verification_requests' AND column_name = 'user_id') THEN
        EXECUTE 'DELETE FROM public.verification_requests WHERE user_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'ad_campaigns' AND column_name = 'advertiser_id') THEN
        EXECUTE 'DELETE FROM public.ad_campaigns WHERE advertiser_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'user_prompts' AND column_name = 'user_id') THEN
        EXECUTE 'DELETE FROM public.user_prompts WHERE user_id NOT IN (SELECT id FROM public.profiles)';
    END IF;
    
    -- Notifying completion
    RAISE NOTICE 'Orphan cleanup completed.';
END $$;


-- =================================================================
-- SECTION 9: FOREIGN KEY CASCADES (Re-applying strictly)
-- =================================================================

DO $$     
BEGIN
    -- PROFILES -> AUTH.USERS
    ALTER TABLE public.profiles DROP CONSTRAINT IF EXISTS profiles_id_fkey;
    ALTER TABLE public.profiles ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;

    -- POSTS -> PROFILES
    ALTER TABLE public.posts DROP CONSTRAINT IF EXISTS posts_user_id_fkey;
    ALTER TABLE public.posts ADD CONSTRAINT posts_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    -- COMMENTS, LIKES, FOLLOWS
    ALTER TABLE public.comments DROP CONSTRAINT IF EXISTS comments_user_id_fkey;
    ALTER TABLE public.comments ADD CONSTRAINT comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    ALTER TABLE public.likes DROP CONSTRAINT IF EXISTS likes_user_id_fkey;
    ALTER TABLE public.likes ADD CONSTRAINT likes_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    ALTER TABLE public.follows DROP CONSTRAINT IF EXISTS follows_follower_id_fkey;
    ALTER TABLE public.follows ADD CONSTRAINT follows_follower_id_fkey FOREIGN KEY (follower_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
    ALTER TABLE public.follows DROP CONSTRAINT IF EXISTS follows_following_id_fkey;
    ALTER TABLE public.follows ADD CONSTRAINT follows_following_id_fkey FOREIGN KEY (following_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    -- ADS, VERIFICATION, PROMPTS
    ALTER TABLE public.ad_campaigns DROP CONSTRAINT IF EXISTS ad_campaigns_advertiser_id_fkey;
    ALTER TABLE public.ad_campaigns ADD CONSTRAINT ad_campaigns_advertiser_id_fkey FOREIGN KEY (advertiser_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    ALTER TABLE public.user_prompts DROP CONSTRAINT IF EXISTS user_prompts_user_id_fkey;
    ALTER TABLE public.user_prompts ADD CONSTRAINT user_prompts_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    ALTER TABLE public.verification_requests DROP CONSTRAINT IF EXISTS verification_requests_user_id_fkey;
    ALTER TABLE public.verification_requests ADD CONSTRAINT verification_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

    RAISE NOTICE 'Foreign Key Cascades applied.';
END $$;


-- =================================================================
-- SECTION 10: RLS POLICIES (Ultimate Config)
-- =================================================================

-- ENABLE RLS on ALL
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.follows ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.advertisements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.verification_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_prompts ENABLE ROW LEVEL SECURITY;

-- 1. POSTS (Strict Verification)
DROP POLICY IF EXISTS "Public posts are viewable by everyone" ON public.posts;
CREATE POLICY "Public posts are viewable by everyone" ON public.posts FOR SELECT USING (true);

DROP POLICY IF EXISTS "Verified users can create posts" ON public.posts;
CREATE POLICY "Verified users can create posts" ON public.posts FOR INSERT 
WITH CHECK (auth.uid() = user_id AND public.is_email_verified());

DROP POLICY IF EXISTS "Users can update own posts" ON public.posts;
CREATE POLICY "Users can update own posts" ON public.posts FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own posts" ON public.posts;
CREATE POLICY "Users can delete own posts" ON public.posts FOR DELETE USING (auth.uid() = user_id);

-- 2. PROMPT AUTOMATIONS (Admin Only Write, Public Read Active)
DROP POLICY IF EXISTS "Admins can manage prompt automations" ON public.prompt_automations;
CREATE POLICY "Admins can manage prompt automations" ON public.prompt_automations FOR ALL TO authenticated
USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'moderator')));

DROP POLICY IF EXISTS "Everyone can view active automations" ON public.prompt_automations;
CREATE POLICY "Everyone can view active automations" ON public.prompt_automations FOR SELECT
USING (is_active = true);

-- 3. USER PROMPTS (Own Data Only)
DROP POLICY IF EXISTS "Users can view own prompts" ON public.user_prompts;
CREATE POLICY "Users can view own prompts" ON public.user_prompts FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can dismiss prompts" ON public.user_prompts;
CREATE POLICY "Users can dismiss prompts" ON public.user_prompts FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own prompts" ON public.user_prompts;
CREATE POLICY "Users can insert own prompts" ON public.user_prompts FOR INSERT WITH CHECK (auth.uid() = user_id);


-- Done!
